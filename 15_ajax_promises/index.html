<!DOCTYPE html>
<html lang="ro">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AJAX &amp; Promises — Frontend Path</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- SIDEBAR -->
    <aside class="sidebar" aria-label="Meniu lateral">
      <h2>Module</h2>
      <nav class="side-nav" aria-label="Navegare module">
        <ul>
          <li>
            <a href="#intro" class="active"
              ><span class="badge">15</span> AJAX 7 &amp; Promises</a
            >
          </li>
          <li>
            <a href="#ajax"><span class="badge">16</span> Ce este AJAX?</a>
          </li>
          <li>
            <a href="#fetch"><span class="badge">17</span> Fetch API</a>
          </li>
          <li>
            <a href="#promises"><span class="badge">18</span> Promises</a>
          </li>
          <li>
            <a href="#async"><span class="badge">19</span> async/await</a>
          </li>
          <li>
            <a href="#erori"><span class="badge">20</span> Erori &amp; CORS</a>
          </li>
          <li>
            <a href="#exercitii"><span class="badge">21</span> Exerciții</a>
          </li>
          <li>
            <a href="#interviu"
              ><span class="badge">22</span> Întrebări interviu</a
            >
          </li>
          <li>
            <a href="#resurse"><span class="badge">23</span> Resurse</a>
          </li>
        </ul>
      </nav>
    </aside>
    <!-- CONȚINUT PRINCIPAL -->
    <main class="main-content" id="top">
      <header>
        <h1>AJAX &amp; Promises</h1>
        <p>
          Comunicare cu serverul fără reîncărcarea paginii și controlul fluxului
          asincron în JavaScript.
        </p>
      </header>
      <article id="ajax">
        <h2>Ce este AJAX?</h2>
        <p>
          <strong>AJAX</strong> este un concept (nu o tehnologie unică) pentru a
          încărca/trimite date către server în fundal folosind JavaScript,
          actualizând UIul fără refresh complet.
        </p>
        <pre><code>// Exemplu simplu cu XMLHttpRequest (legacy)
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');
xhr.onload = () => console.log(xhr.responseText);
xhr.onerror = () => console.error('Eroare de rețea');
xhr.send();
</code></pre>
      </article>
      <article id="fetch">
        <h2>Fetch API</h2>
        <p>
          <code>fetch()</code> oferă o interfață modernă bazată pe
          <em>Promise</em> pentru cereri HTTP.
        </p>
        <pre><code>// GET cu fetch
fetch('https://jsonplaceholder.typicode.com/todos/1')
 .then((res) => {
 if (!res.ok) throw new Error(`HTTP ${res.status}`);
 return res.json();
 })
8
 .then((data) => console.log(data))
 .catch((err) => console.error('Eșec:', err));
</code></pre>
        <h3>POST JSON</h3>
        <pre><code>async function createTodo(todo) {
 const res = await fetch('https://jsonplaceholder.typicode.com/todos', {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify(todo),
 });
 if (!res.ok) throw new Error(`HTTP ${res.status}`);
 return res.json();
}
</code></pre>
      </article>
      <article id="promises">
        <h2>Promises</h2>
        <p>
          Un <em>Promise</em> reprezintă rezultatul unei operații asincrone:
          <code>pending</code> → <code>fulfilled</code> sau
          <code>rejected</code>.
        </p>
        <pre><code>const wait = (ms) => new Promise((resolve) =>
setTimeout(resolve, ms));
wait(500)
 .then(() => 'gata!')
 .then(console.log)
 .catch(console.error)
 .finally(() =&gt; console.log('cleanup'));
</code></pre>
        <h3>Combinarea Promiselor</h3>
        <pre><code>const p1 = fetch('/a');
const p2 = fetch('/b');
// rulează în paralel și așteaptă toate
Promise.all([p1, p2]).then(([r1, r2]) => { /* ... */ });
// returnează prima rezolvată sau respinsă
Promise.race([p1, p2]).then(/* ... */);
// așteaptă orice Promise (rezolvat sau respins)
Promise.allSettled([p1, p2]).then(results => console.log(results));
</code></pre>
      </article>
      <article id="async">
        9
        <h2>async/await</h2>
        <p>Sintaxă sugar peste Promises pentru cod mai lizibil.</p>
        <pre><code>async function getTodo(id) {
 try {
 const res = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`);
 if (!res.ok) throw new Error('HTTP ' + res.status);
 const data = await res.json();
 return data;
 } catch (err) {
 console.error('Eșec:', err);
 throw err; // propagă eroarea
 }
}
</code></pre>
      </article>
      <article id="erori">
        <h2>Gestionarea erorilor &amp; CORS</h2>
        <ul class="bullets">
          <li>
            <strong>Erori de rețea</strong> (offline, timeout) vs
            <strong>erori HTTP</strong> (4xx/5xx).
          </li>
          <li>
            <strong>CORS</strong>: serverul trebuie să permită originea ta
            (antetele <code>Access-Control-Allow-*</code>).
          </li>
          <li>
            Tratează <code>res.ok</code> și parsează <code>res.json()</code> în
            blocuri <code>try/catch</code>.
          </li>
        </ul>
        <pre><code>async function safeFetch(url, options) {
 try {
 const res = await fetch(url, options);
 if (!res.ok) {
 const text = await res.text();
 throw new Error(`HTTP ${res.status}: ${text}`);
 }
 return res.json();
 } catch (err) {
 // retry, fallback UI, logare
 console.error('Request a eșuat:', err);
 throw err;
 }
}
</code></pre>
      </article>
      <section id="exercitii">
        <h2>Exerciții practice</h2>
        <div class="exercise-card">
          <h3>1) TODO List din API public</h3>
          <p>
            Folosește <code>fetch</code> pentru a încărca primele 5 TODO-uri și
            10 afișează-le într-o listă. Adaugă un indicator de încărcare și
            tratează erorile.
          </p>
          <button id="load-todos" class="eye-btn" type="button">
            Încarcă TODOuri
          </button>
          <ul id="todos" class="list"></ul>
        </div>
        <div class="exercise-card">
          <h3>2) POST cu feedback UI</h3>
          <p>
            Trimite un nou TODO și afișează răspunsul serverului într-un card.
          </p>
        </div>
      </section>
      <section id="interviu" class="interview">
        <h2>Întrebări de interviu</h2>
        <div class="question">
          <p>
            <strong
              >1. Diferența între <code>Promise.all</code> și
              <code>Promise.allSettled</code>?</strong
            >
          </p>
          <button class="eye-btn">Vezi răspunsul</button>
          <div class="answer">
            <code>Promise.all</code> respinge dacă oricare Promise eșuează;
            <code>Promise.allSettled</code> așteaptă toate și oferă status
            pentru fiecare (fulfilled/rejected) fără a respinge global.
          </div>
        </div>
        <div class="question">
          <p>
            <strong>2. Cum tratezi erorile cu <code>async/await</code>?</strong>
          </p>
          <button class="eye-btn">Vezi răspunsul</button>
          <div class="answer">
            Înfășori codul în <code>try/catch</code>; poți rearunca eroarea
            pentru a o gestiona la un nivel superior sau pentru a afișa feedback
            în UI.
          </div>
        </div>
      </section>
      <section id="resurse">
        <h2>Resurse utile</h2>
        <ul>
          <li>MDN: Fetch API &amp; Promises.</li>
          <li>Public APIs (ex: JSONPlaceholder) pentru testare.</li>
          <li>
            Tutoriale despre <code>async/await</code> și tratarea erorilor.
          </li>
        </ul>
      </section>
      <footer>
        <p>© 2025 Frontend Learning Path — AJAX &amp; Promises</p>
      </footer>
    </main>
    11
    <script src="app.js"></script>
  </body>
</html>
